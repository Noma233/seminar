% \documentclass[ams]{U-AizuGT}
\documentclass[ams]{article}
\usepackage[margin=20truemm]{geometry}
\usepackage{setspace}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{listings}
\usepackage{physics}
\usepackage{amsmath}
\usepackage{here}
\lstset{
    frame=single,
    breaklines=true,
    lineskip=-0.5ex,
    frame={tb},
}

% \lstset{
%   basicstyle={\ttfamily},
%   identifierstyle={\small},
%   commentstyle={\smallitshape},
%   keywordstyle={\small\bfseries},
%   ndkeywordstyle={\small},
%   stringstyle={\small\ttfamily}
%   frame={tb},
%   % breaklines=true,
%   % columns=[l]{fullflexible},
%   % numbers=left,
%   % % xrightmargin=0zw,
%   % % xleftmargin=3zw
%   % numberstyle={\scriptsize},
%   % stepnumber=1
%   % numbersep=1zw,
%   % lineskip=-0.5ex
% }




% \author[]{Ryuki Hiwada}
% ハイフネーション禁止
\hyphenpenalty=10000\relax
\exhyphenpenalty=10000\relax
\sloppy

\bibliographystyle{ieicetr}

% \author{Ryuki Hiwada}
% \studentid{s1280076}
% \supervisor{Prof. Naohito Nakasato}
\title{Domain Specific Language For High-Performance Computing}
\begin{document}
	\maketitle
	\begin{abstract}
		The abstract of your thesis must be written here.
	\end{abstract} 
	
	\section{Introduction}

Particle simulations have been performed in various research fields such as astrophysics and molecular dynamics. For example, in astrophysics, we simulate the dynamical evolution due to gravity between stars,
and in molecular dynamics, we simulate the motion of molecules.
Particle simulations are computationally expensive when the number of particles involved is large.
    In $N$-body simulation, most of the computational time is used to calculate 
the gravitational interaction. Equation\eqref{eq:gravity} is 
the equation for the gravitational acceleration for ith particle.


\begin{equation}
\vb{a}_i = \sum_{\substack{j \neq i}}^{N} G m_j \frac{\vb{x}_j - \vb{x}_i}{\left( \left| \vb{x}_j - \vb{x}_i \right| + \epsilon^2 \right)^{3/2}\label{eq:gravity}}
\end{equation}


$\vb{a}_i$ is the acceleration, $\vb{x}_i$ is position of the particle i,
$m_j$ is the mass of the particle j, $\vb{x}_j$ is position of the particle j,
$N$ is the number of particles.

In addition, $G$ and $\epsilon$, are the gravitational constant and a softening parameter to prevent divergence.
From Equation \eqref{eq:gravity}, the time complexity of the calculation for N particles is proportional to 
the square of the number of particles N.

 $N$-body simulations often require large numbers of particles.
For example, a globular cluster contains about $10^4$ to $10^6 $ stars.
Therefore, For $N$-body simulation parallel computing is generally used to speed up the computation.



The computation of particle interactions has high
data parallelism because the computation of particles is 
independent of each other. Therefore, 
 SIMD\lparen Single Instruction/Multiple Data\rparen parallelism, 
one of Flynn's taxonomy \cite{flynn1972some}, is applicable to speed up the computation.
However, to execute SIMD instructions, we need to write an assembler or an intrinsic function.
Use SIMD intrinsic functions to handle SIMD instructions in high-level languages such as c and C++.
 

The goal of this study is that Pyker can compute particle interactions faster than non-parallelized code, and it takes fewer instructions.

For this purpose, Pyker generates the parallelized code using SIMD instructions from the Domain Specific Language\lparen DSL\rparen code for particle interaction.
A DSL is a programming language for solving specific problems.
Pyker generates the code to compute particle interactions from the definition of variables and 
the description of formulas.


In this paper, to investigate the accuracy of the computations performed by the code generated with Pyker, we use PIKG\cite{PIKG}. PIKG is a tool for automatically generating particle interaction kernel functions for FDPS\cite{FDPS} and other particle simulators, capable of generating kernel codes for various CPU and parallel architectures, including Intel CPU, Fujitsu A64FX, NVIDIA GPU, and PEZY-SC2, based on the same descriptions as Pyker.
We design Pyker to be compatible with PIKG so that we can input the same description in DSL into both PIKG and Pyker and then evaluate the relative errors in the computational results generated by the PIKG and Pyker. Furthermore, to evaluate the rate of acceleration of the SIMD code generated by Pyker, we compare its execution times with the code without SIMD parallelized by the generated PIKG.


We also generated a SIMD code using PIKG and measured its computation time using the same method to compare the performance of the computation speed of the codes generated by PIKG and Pyker, respectively.

We then applied these codes to the three particle interaction equations to see if there was any difference in computation time.
To evaluate the DSL code for Pyker, we compared the DSL code and generated code for Pyker.


In this paper, Section 2 explains how Pyker defines the particle interaction equation, Section 3 describes the process of code generation by Pyker, and Section 4 presents the results of the performance experiments.

\section{Definition of the particle interaction in DSL}

\subsection{Particle interaction}
In this section, we explain the information needed to compute the particle interaction, such as Equation\eqref{eq:gravity}, using an actual code.
Listing \ref{template} shows an example of C++ source code that performs the calculation 
in Equation \eqref{eq:gravity}.
% [frame=single, caption=skeletoncode, label=sleltoncode]


\begin{lstlisting}[frame=single, caption=gravitational\_interaction.cpp, label=template,  breaklines=false, language=c++, basicstyle=\small]
              
for (int i = 0; i < n; i++) {
double ax = 0.0;
double ay = 0.0;
double az = 0.0;

for (int j = 0; j < n; j++) {
    double dx = xj[j][0]-xi[i][0];
    double dy = xj[j][1]-xi[i][1];
    double dz = xj[j][2]-xi[i][2];
    double r2 = dx*dx+dy*dy+dz*dz+eps2;
    double ri2 = 1.0f/sqrt(r2); 
    
    double mr = mj[j]*ri2*ri2*ri2;

    ax += double(mr*dx);
    ay += double(mr*dy);
    az += double(mr*dz);
}

acci[i][0] = ax;
acci[i][1] = ay;
acci[i][2] = az;
}
\end{lstlisting}

We briefly describe how this code corresponds to the Equation 
\eqref{eq:gravity}. The array variables acci, xi, mj, and xj correspond to
 $\vb{a}_i$, $\vb{x}_i$, $m_j$, and $\vb{x}_j$, respectively. And, the constants n and eps2, corresponds to $N$ and $\epsilon$
respectively. We need the nested loop with loop variables i and j. The inner loop calculates the acceleration for ith particle. The gravitational constant $G$ is not in the code because it can be calculated after the 
calculation of the particle interactions.


 From this code, we see that we need three categories of information to generate a code for particle interaction such as Listing \ref{template}.
\begin{itemize}
  \item The information on the type of each variable
  \item For array variables, we need to identify whether the variables are indexed by the loop variable i or j
  \item Which array variables are used to store the result

\end{itemize}

 With the definition of variables and the description of the
particle interaction using the variables, a code to calculate the
particle interaction can be generated.
The language specification in the next section of our DSL in the next section.


\subsection{Language specification}
There are two parts in the DSL for Pyker: (1) variable declaration and 
(2) particle interaction description.
First, we explain the variable definition.

The next section describes the process of generating SIMD code from the written code in this DSL.
\subsubsection{Variable declaration part}

In DSL for Pyker, variable declarations are defined as follows.

\begin{align*}
\text{\textless variable definition\textgreater} &::= \text{\textless category\textgreater\text{  }   \textless type\textgreater \text{  }  \textless name\textgreater} \\
\text{\textless category\textgreater} &::= \text{"EPI"} \mid \text{"EPJ"} \mid \text{"FORCE"} \mid \epsilon \\
\text{\textless type\textgreater} &::= \text{"vec3\textless F64\textgreater"} \mid \text{"F64"} \\
\text{\textless name\textgreater} &::= \text{\textless character\textgreater} \mid \text{ \{\textless character\textgreater \}}\\
\text{\textless character\textgreater} &::= \text{\textless letter\textgreater} \mid \text{\textless digit\textgreater} \mid "\_"\\
\text{\textless letter\textgreater} &::= \text{"a"} \mid \text{"b"} \mid ... \mid \text{"z"} \mid \text{"A"}\mid \text{"B"} ... \mid \text{"Z"}\\
\text{\textless digit\textgreater} &::= \text{"1"} \mid \text{"2"} \mid ... \mid \text{"9"} \\
\end{align*}

The above Backus-Naur form (BNF) representation of variable definitions is the grammar rule for variable definitions in our DSL.
Variable definitions are divided into three parts,\textless category\textgreater, \textless type\textgreater, and \textless name\textgreater.

\textless category\textgreater \text{ } defines a kind of variable, EPI and EPJ indicate that a variable to store data for particles i and j,
respectively. FORCE indicates that a variable to store the results. If there is no \textless category\textgreater in a variable definition, the variable is a constant or a temporary variable.
\textless type\textgreater \text{ } defines a type of variable
vec3 \textless F64 \textgreater represents vectors in 3 dimensions and F64 represents a scalar.

Vector elements and scalar are double-precision floating point numbers.

\textless name\textgreater \text{ } defines the variable name.


 An example of a variable definition is shown below.
\[
  EPI\text{ } vec3<F64> \text{ } ri
\]
It declares this variable is the EPI category, the type is vectors and the variable name is ri.

\subsubsection{Particle interaction expression part}
 % assignment, and '+=' for formulas.=, +=
 In our DSL, we use the defined variables either EPI, EPJ and temporary variables to, describe the particle interaction calculation. At the end of the description, we should assign the calculation result to the variables declared as the FORCE variables.
 
 We can use four basic arithmetic operations and the square root function sqrt(), the power function, and the vector inner product in the particle interaction expression. 
 We can use "*" to represent the inner product between two vectors such as, "x*y" when both x and y are vectors. For the power function, we use the notation of "x**a", where we calculate the power of x with respect to a. 



 Listing \ref{pyker} is an example of a Pyker description of the calculation of the Equation\eqref{eq:gravity}.
 In this list, Lines from one to five are the declaration part and the remaining is the particle interaction expression part.
 For example, we assign the part of the calculation to the temporary variables rij, r2, and r\_inv in lines six, seven, and eight respectively.
 In this line, we compute the relative distance squared between particles using the inner product notation for "rij". 
 
 In the last line, a temporary variable is used to assign the result of the calculation to ai, a FORCE variable, with '+='.
 
% , caption=gravity\_particle, label=pikg-example
\begin{lstlisting}[caption=example of the DSL,frame=single, numbers=left, label=pyker]
  EPI vec3<F64> ri
  EPJ vec3<F64> rj
  EPJ F64 mass
  EPJ F64 eps2
  FORCE vec3<F64> ai
  rij = ri - rj
  r2 = rij * rij + eps2
  r_inv = 1.0 / sqrt(r2)
  r2_inv = r_inv * r_inv
  mr_inv = mass * r_inv
  mr3_inv = r2_inv * mr_inv
  ai += mr3_inv * rij
\end{lstlisting} 

The next section explains the processing of Pyker for generating SIMD code from code written in this DSL.


\section{Process of Pyker}


\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/flowchart_ver5.png}
\caption{Flow of Pyker}
\label{fig:flowchart}
\end{figure}

This section describes the processing flow of Pyker. The processing consists of four phases: Parsing, Type inference, Translation for SIMD instructions, and Code generation.


During the Parsing phase, a hash map of variable definitions is created from an input DSL, and expressions in the DSL are converted into an abstract syntax tree(AST). This hash map and AST are then passed to the next phase, Type inference. In the Type inference phase, the types of temporary variables are inferred.
Next, Translation for SIMD instructions phase, Pyker modifies the AST. Next, a SIMD code for the particle calculation is generated from the modified AST.


We use Sympy, a Python library for algebraic computation, to implement Pyker. With Sympy, an input DSL code is converted into Sympy's AST after the loading. In Pyker, we primarily process the AST using the API provided by Sympy.
In the following subsection, we describe each phase in more detail.



\subsection{Parsing phase}
The parsing phase converts the DSL code into a variable definition hash map (var\_map) and an expression syntax tree.
var\_map takes the variable name as key and an instance of the Var class defined in this study as value. the Var class holds the attributes of the variable, such as type and value. In Pyker, such as the type and value of the variable.
In addition, it also adds the numerical values contained in the syntax tree to the var\_map. This is because numerical values must also be vectorized as parallelization targets when applying SIMD instructions.


 To convert a formula into an AST, use the sympify() method. This method has the ability to take a formula in string form as an argument and convert it into an AST on Sympy.
 

var\_map and syntax tree are passed to the next process, the type inference phase. The type inference phase infers the types of temporary variables and prepares them for code generation.

\subsection{Type inference phase}
In this phase, the main focus is on type inference for temporary variables. 
In Pyker the types are only double-precision floating point numbers, so the focus is only on the inference of the dimension of a variable. It is necessary to know what the dimension of the value returned by a sub-expression is.
For example, in the case of the expression "x * y * z", if x and y are vectors and z is a scalar, we know that the result of the expression is a scalar. Therefore, we recursively traverse the AST to perform the type inference. During this process, we also replace the inner product with the 'dot' function. In Sympy, the FunctionCall object is used to define the function name and arguments, which can then be incorporated into the parse tree.

\subsection{Translation for SIMD instruction phase}
In this phase, Pyker performs the following three modifications to the  AST on Sympy.
\begin{itemize}
  \item Converting to a complete binary tree
  \item Identification of operators
  \item Replacing the operator nodes with SIMD intrinsic functions

\end{itemize}

In the AST on Sympy, if there are three or more terms with the same operator and order of computation, these terms are grouped as children of a single operator node as shown in Figure \ref{fig:f1}. However, SIMD instructions are binary operations. Therefore, it is necessary to convert the AST into a complete binary tree.

Additional modifications are required because the AST of Sympy only supports the nodes of the Add, Mul, and Pow operations. Add represents addition, Mul represents multiplication, and Pow represents power. And operations such as subtraction, division, and sqrt() are represented using these three operators. For example, Figure \ref{fig:f2} shows the AST of the expression 'a-b', which is a minus b. In addition, any operation indicating exponentiation is converted to multiple Mul operations since SIMD instructions do not support exponentiation.
And 'dot' methods, also translate the Mul and Add operations.


After the operator is identified, it is replaced by the corresponding SIMD intrinsic function by a FunctionCall object.
The FunctionCall object with the name of the intrinsic function corresponding to the operator replaces the node in the AST, and the corresponding intrinsic function is generated when the code is generated from the AST.

If the AST of Figure \ref{fig:f2} is replaced with an intrinsic function, the result is as shown in Figure \ref{fig:f3}.


\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/multi_arg.png}
\caption{The Sympy AST of the expression'a+b+c'}
\label{fig:f1}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/sub_tree.png}
\caption{The Sympy AST of the expression 'a-b'}
\label{fig:f2}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/SIMDintrisic.png}
\caption{The Sympy AST of the expression SIMD intrinsic function name FunctionCall object}
\label{fig:f3}
\end{figure}


\subsection{Code generation phase}
We use the ccode() method included in the Codegen module on Sympy in the code generation phase. The ccode() method generates the corresponding C++ code by passing a Sympy format as an argument.  So, the code that is generated by passing this AST to ccode() is an argument.


In addition to this, there are other elements necessary for SIMD. This is done by loading multiple data into a wide-bit SIMD register and then executing a single instruction between these registers. Therefore, there is loading of data into SIMD register, store of results, and so on. These processes are put into a Sympy format and the desired code is generated.
% SIMDを行うには、
% 例えば、配列x,yの要素同士の足し算を行うとき、
% 以下のようなる。


% \ref{lst:simd}
% SIMD calculations use dedicated SIMD registers.

\section{Execution Environment}

Table \ref{tb:exe} is the execution environment.
The code generated by Pyker used AVX2 as the SIMD instruction set.

Therefore, the SIMD parallelization code for PIKG was also made to use the AVX2 instruction set as well.

			\begin{table*}[htb]
                    \centering
				\caption{Execution Environment}
				\label{tb:exe}
				\begin{tabular}{|c||c|} \hline
					OS & Windows Subsystem for Linux  \\ \hline 
					CPU & AMD Ryzen 5 3600 6-Core Processor 3.60 GHz \\ \hline
                        compiler & g++ 9.4.0 \\ \hline
					compile option & mavx2, O3   \\ \hline
					SIMD instruction & AVX2  \\ \hline
				\end{tabular}
			\end{table*}


\section{Experiments}
In this section, we present the evaluation of Pyker. For the evaluation, we use three particle interactions: Case A is the gravity interaction as shown in Equation\eqref{eq:gravity}. 
Case B is the gravitational interaction used in the Hermite integration as shown in Equation \ref{eq:hermite}, And Case C is the Lennard-Jones interaction used in the molecular dynamics as shown in Equation \ref{eq:lennard}.


We also compared the number of operations in DSL for Pyker description of each Case with the number of intrinsic functions in generated code for Pyker to evaluate Whether the DSL code could have been written with less code than the parallelized code.

And for each, the DSL code for Pyker is shown.

\begin{align}\label{eq:hermite}
F &= \sum\limits_{j\neq i}^N \frac{m_j \cdot \mathbf{r_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2\right)^{\frac{3}{2}}}, &
J &= \sum\limits_{j\neq i}^N \frac{m_j \cdot \mathbf{v_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{3}{2}}} - \frac{3 \cdot m_j \cdot \mathbf{r_{ij}} \cdot \mathbf{v_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{5}{2}}}
\end{align}


\begin{align}\label{eq:lennard}
U =\sum\limits_{j\neq i}^N  4 \left[ \left( \frac{1}{r_{ij}} \right)^{12} - \left( \frac{1}{r_{ij}} \right)^{6} 
\right],
F =\sum\limits_{j\neq i}^N  4 \left[ 12\left( \frac{1}{r_{ij}} \right)^{11} - 6\left( \frac{1}{r_{ij}} \right)^{5}\right]
\end{align}

We generate three codes in each case by using both Pyker and PIKG:(1) the code generated without parallelization in PIKG (non-SIMD-PIKG), (2) the code generated with SIMD parallelization in PIKG (SIMD-PIKG), and (3) the code generated from Pyker (SIMD-Pyker) generated from Pyker. The AVX2 instructions were used for SIMD parallelization of both PIKG and Pyker. We ran these codes and measured the execution times.


The experimental results are presented in Tables \ref{tb:resultA}, 3, and 4. In all tables, the first column shows the number of particles $N$. The second, third, and fourth columns show the execution time of SIMD-Pyker $T_{Pyker}$, non-SIMD-PIKG $T_{Ref}$, and SIMD-PIKG $T_{PIKG}$, respectively. The fifth column shows the ratio between $T_{Ref}$ and $T_{Pyker}$ which indicates how much faster SIMD-Pyker is than non-SIMD-PIKG. Also, the sixth column shows the ratio between $T_{PIKG}$ and $T_{Pyker}$ which represents how much faster SIMD-Pyker is than SIMD-PIKG.


    \subsection{Case A}
\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\linewidth]{seminar/caseA.png}
\caption{DSL code of Case A}
\label{fig:caseA}
\end{figure}

Figure \ref{fig:caseA} shows the DSL code of Case A.

The results of the evaluation of Case A are shown in Table \ref{tb:resultA}.
$S_{Ref}$ in Table \ref{tb:resultA} is greater than four for any N. SIMD-Pyker was computed more than four times faster than SIMD-PIKG. Also, since $S_{PIKG}$ is about one for every N, SIMD-Pyker had about the same computation time as SIMD-PIKG.



\subsection{Case B}
\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/caseB.png}
\caption{DSL code of Case B}
\label{fig:CaseB}
\end{figure}
Figure \ref{fig:CaseB} shows the DSL code of Case B.
The computation time results in B are shown in Table \ref{tb:resultB}.$S_{Ref}$ is almost the same as Case A. Also, $S_{PIKG}$ is 0.7 to 0.8 for any N. Therefore, in case B, SIMD-Pyker was slower than SIMD-PIKG.



\subsection{Case C}
\begin{figure}[htbp]
\centering
\includegraphics[width=0.5\linewidth]{seminar/caseC.png}
\caption{DSL code of Case C}
\label{fig:CaseC}
\end{figure}
Figure \ref{fig:CaseC} shows the DSL for Case C.
The results of the computation in C are shown in Table \ref{tb:resultC}. $S_{Ref}$ in Table \ref{tb:resultC} is greater than 4.5 for any N. Therefore, $T_{Pyker}$ was computed more than 4.5 times faster than $T_{Ref}$. $S_PIKG$ is almost the same as Case A. Therefore, $T_{Pyker}$ had about the same computation time as $T_{PIKG}$.



 \subsection{Evaluation of DSL code}
Table \ref{tb:dslev} shows the number of operations in the DSL and the number of intrinsic functions in the Pyker-generated code for Cases A, B, and C, respectively.

$i_f$ is the number of intrinsic functions in cases A, B, and C.
$D_p$ is the number of operations in DSL for Pyker in cases A, B, and C.
In DSL operations, "+, -, /, *, sqrt(), **" are each one operation.

The table shows that in all cases the DSL code has fewer operations.

 
		\begin{table}[htb]
                    \centering
				\caption{Compare $i_f$ and $D_p$}
				\label{tb:dslev}
				\begin{tabular}{|c||c|c|c|} \hline
 & Case A & Case B & Case C  \\ \hline\hline
$D_p$ &9 &18& 25\\ \hline
$i_f$&31&64& 40\\ \hline
				\end{tabular}
			\end{table}

\section{Discussion}

From the experimental results, SIMD-Pyker was more than four times faster in execution time than non-SIMD-PIKG in all cases. SIMD Parallelized computations are proportionally faster than non-parallelized computations in terms of the number of data computed simultaneously. SIMD parallelized computations are twice as fast as non-parallelized computations in terms of the number of data simultaneously computed. Pyker used the AVX2 SIMD instruction set, and the SIMD registers used in this instruction set are 256-bit. In addition, all variable types are 64-bit precision floating numbers in this experiment. Therefore, four variables were loaded into the SIMD registers and computed, the speed up with SIMD is up to four times faster than when processing non-parallelized computations. Therefore, SIMD-Pyker was able to achieve the maximum speedup expected.

 
 However, in case B, SIMD-Pyker is slower than SIMD-PIKG. The most likely cause is the most computationally intensive process, the innermost process of the nested loop. To compare these processes, Table \ref{tb:table} shows the number of calls to the intrinsic function of the nested loop in SIMD-Pyker and SIMD-PIKG for each of cases A, B, and C. In Case B, SIMD-Pyker and SIMD-PIKG both have more number of operations than A and C.
		\begin{table}[htb]
				\caption{Number of intrinsic functions}
				\label{tb:table}
				\begin{tabular}{|c||c|c|c|} \hline
				  & case of A & case of B & case of C \\ \hline \hline
				Pyker & 22 & 46 & 26 \\ \hline
			PIKG	& 18 & 40 & 27  \\ \hline
				\end{tabular}

			\end{table}

\section{Conclusion}
SIMD-Pyker was computationally faster than the non-SIMD-PIKG code in all cases.
In addition, Pyker had fewer DSL operators than the number of intrinsic functions in the generated code in any case.

    \begin{table}[bht]
            \centering

            \caption{Result of Case A}
            \label{tb:resultA}
                \begin{tabular}{|c||c|c|c|c|c|} \hline
N &$T_{Pyker}$(sec)&$T_{Ref}$(sec)&$T_{PIKG}$(sec)&$S_{Ref}$&$S_{PIKG}$\\ \hline\hline
50000 &2.477  &10.794& 2.440& 4.36 & 0.99 \\ \hline
25000 & 0.617  &2.693& 0.599& 4.36 & 0.97 \\ \hline
10000 &0.095   &0.425& 0.095& 4.48 & 1.00 \\ \hline
 1000 &0.001   &0.004& 0.001& 4.52 & 1.05 \\ \hline

                \end{tabular}\hfill
    \end{table}
    \begin{table}[htb]
                \centering
				\caption{Rusult of Case B}
				\label{tb:resultB}
				\begin{tabular}{|c||c|c|c|c|c|} \hline
N & $T_{Pyker}$(sec) & $T_{Ref}$ (sec) & $T_{PIKG}$(sec) &$S_{Ref}$ & $S_{PIKG}$ \\ \hline\hline
50000 & 5.282&22.768 &4.059 & 4.31&0.77\\ \hline
25000 & 1.323& 5.740&1.008 & 4.34&0.76\\  \hline
10000 & 0.214&0.902 &0.169 & 4.22&0.76 \\ \hline
1000  &0.002&0.009 & 0.002 & 4.30&0.81\\  \hline
				\end{tabular}
        \end{table}
    
		\begin{table}[htb]
                    \centering
				\caption{Result of Case C}
				\label{tb:resultC}
				\begin{tabular}{|c||c|c|c|c|c|} \hline
N & $T_{Pyker}$(sec) & $T_{Ref}$(sec) & $T_{PIKG}$(sec) &$S_{Ref}$ & $S_{PIKG}$ \\ \hline\hline
50000 &2.154 &9.904& 2.195& 4.60& 1.02\\ \hline
25000 &0.542 &2.480& 0.554& 4.57& 1.02\\ \hline
10000 &0.086 &0.399& 0.087& 4.66& 1.02\\ \hline
 1000 &0.001 &0.004& 0.001& 4.50& 1.01\\ \hline

				\end{tabular}
			\end{table}
    


       
    % \begin{table}[htb]
    %         \centering
    %         \caption{Number of line of each code}
    %         \label{tb:column}
    %             \begin{tabular}{|c|c|c|c|c|} \hline
    %     Nbody  & Hermite  & Lennard Jones  \\ \hline
    %     gravity particle & 70 & 12 \\ \hline
    %     Hermite               & 123 & 20  \\ \hline
    %     Lennard Jones         &60 & 22  \\ \hline
   
    %             \end{tabular}
    % \end{table}


		
	\bibliography{biblist}




% F = \frac{m_j \cdot \mathbf{r_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{3}{2}}}
% \begin{equation}
% F = \frac{m_j \cdot \mathbf{r_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{3}{2}}}
% \end{equation}



% rij = ri - rj, vij = vi - vj, \\

% \begin{align}
% F = m_j\frac{ \mathbf{\mathbf{r_i} - \mathbf{r_j}}}{\left|\mathbf{r_i} - \mathbf{r_j}\right|^3}, &
% J = m_j \frac{\mathbf{v_i} - \mathbf{v_j}}{\left|\mathbf{r_i} - \mathbf{r_j}\right|^3} - 3 m_j \frac{(\mathbf{r_i} - \mathbf{r_j})  (\mathbf{v_i} - \mathbf{v_j})}{\left|\mathbf{r_i} - \mathbf{r_j}\right|^5}
% \end{align}


\end{document} 

% \begin{lstlisting}[frame=single]
%   dx0 = pos[i][0] - pos[j][0]
%   dx1 = pos[i + 1][0] - pos[j][0]
%   dx2 = pos[i + 2][0] - pos[j][0]
%   dx3 = pos[i + 3][0] - pos[j][0]
% \end{lstlisting}

% \begin{lstlisting}[frame=single]
%   (x1, x2, x3, x4) + (y1, y2, y3, y)

% \end{lstlisting}

% \begin{align}
% F &= \frac{m_j \cdot \mathbf{r_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{3}{2}}}, &
% J &= \frac{m_j \cdot \mathbf{v_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{3}{2}}} - \frac{3 \cdot m_j \cdot \mathbf{r_{ij}} \cdot \mathbf{v_{ij}}}{\left( \mathbf{r_{ij}}^2 + \epsilon^2 \right)^{\frac{5}{2}}}
% \end{align}

% \end{document} 
% \begin{}

