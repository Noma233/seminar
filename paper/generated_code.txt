\begin{lstlisting}[frame=single, caption=hoge]
//(1) include part
#include<math>
#include<immintrin.h>
int kernel( (2) double xi[][3], double xj[][3], double eps2, double ai[][3], ...) {
  //(3) decleare tmp variable
  int i;
  int j;
  __m256d xi_tmp_v0;
  __m256d xi_tmp_v1;  
  __m256d xi_tmp_v2;
  __m256d eps2_tmp;
  // ... 
  // ... 
  // ... 
  //(4) def not class variables
  eps2_tmp = _mm256_set1_pd(eps2);
  // ... 
  // ... 
  // ... 
  
  // (5) loop increment
  for(i = 0;i < n;i += 4) {
    // (6) Load EPI variable part
    int index_gather_0[4] = {0, 3, 6, 9};
    __m128i vindex_gather_0 = _mm_load_si128((const __m128i*)index_gather_0);    
    // ... 
    // ... 
    // ... 

    // (7) initialize result temporary variable
    ai_tmp_v0 = _mm256_set1_pd(0.0);
    ai_tmp_v1 = _mm256_set1_pd(0.0);
    ai_tmp_v2 = _mm256_set1_pd(0.0);


    for(j = 0;j < n;j += 1) {
      // (8) Load EPJ variable part
         xj_tmp_v0 = _mm256_set1_pd(xj[j][0]);
         xj_tmp_v1 = _mm256_set1_pd(xj[j][1]);
         xj_tmp_v2 = _mm256_set1_pd(xj[j][2]);
        // ... 
        // ... 
        // ... 
         

      // (9) calculate interparticle
        dr_tmp_v0 = _mm256_sub_pd(xj_tmp_v0, xi_tmp_v0);
        dr_tmp_v1 = _mm256_sub_pd(xj_tmp_v1, xi_tmp_v1);
        dr_tmp_v2 = _mm256_sub_pd(xj_tmp_v2, xi_tmp_v2);
        ai_tmp_v0 += _mm256_div_pd(_mm256_mul_pd(//.....));
        ai_tmp_v1 += _mm256_div_pd(_mm256_mul_pd(//.....));
        ai_tmp_v2 += _mm256_div_pd(_mm256_mul_pd(//.....));

    }

    // (10) Store result part

  }
  return 0;
}
\end{lstlisting}
