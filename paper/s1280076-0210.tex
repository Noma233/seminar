\documentclass[ams]{article}
\usepackage[margin=20truemm]{geometry}
\usepackage{setspace}
\doublespacing
\usepackage{pifont}
% \usepackage{graphicx}
\usepackage{cite}
\usepackage{mathtools}
% \usepackage{listings,jvlisting}
% \documentclass[a4j]{jarticle} %ここは関係ない
\usepackage{listings,jvlisting} 
\usepackage[dvipdfmx]{graphicx}
\usepackage{physics}

\usepackage[utf8]{inputenc}
\usepackage{booktabs} % きれいな表を作成するためのパッケージ

\bibliographystyle{ieicetr}

\lstset{
    frame=single,
    numbers=left,
    tabsize=2
}


% \usepackage{listings,jlisting}

% \lstset{%
%   language={C},
%   basicstyle={\small},%
%   identifierstyle={\small},%
%   commentstyle={\small\itshape},%
%   keywordstyle={\small\bfseries},%
%   ndkeywordstyle={\small},%
%   stringstyle={\small\ttfamily},
%   frame={tb},
%   breaklines=true,
%   columns=[l]{fullflexible},%
%   numbers=left,%
%   xrightmargin=0zw,%
%   xleftmargin=3zw,%
%   numberstyle={\scriptsize},%
%   stepnumber=1,
%   numbersep=1zw,%
%   lineskip=-0.5ex%
% }
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}

% \bibliographystyle{ieice}
\author{Ryuki Hiwada}
% \studentid{s1280076}
% \supervisor{Naohito Nakasato}

\title{Domain Specific Language for high performance computing}

\begin{document}

\maketitle
\begin{abstract}

\end{abstract}
\section{Introduction}


\subsection{Background}

Particle simulations have been executed in various fields such as 
astrophysics and fluid dynamics. For example, N-body simulations 
simulate the dynamical evolution due to gravity between planets,
and models of fluid motion models simulate water.
Particle simulations are computationally demanding
with respect to the number of particles.
As an example, we will discuss the case of an N-body simulation.
In this simulation, most of the computational time is occupied by
the calculation of the gravitational interaction. equation \eqref{eq:gravity} is 
the equation for the gravitational interaction.

\begin{equation}
a_i = \sum_{\substack{j \neq i}}^{N} G m_j \frac{\vb{x}_j - \vb{x}_i}{\left( \left| \vb{x}_j - \vb{x}_i \right| + \epsilon^2 \right)^{3/2}\label{eq:gravity}}
\end{equation}

$a_i$, $\vb{x}_i$ $m_j$,$\vb{x}_j$,$N$,$G$,$\epsilon$
are the acceleration and position of particle i, the mass of particle j, the number of position particles, respectively, and
softening parameters to prevent gravitational constant divergence.
From equation \eqref{eq:gravity},time complexity is proportional to 
the number of particles N, 

 N-body simulations often require large numbers of particles.
For example, a globular cluster contains about $10^4 ~ 10^5 $ stars.
Therefore, very long computation time is required.  parallel computing is 
generally used to speed up the process.


The computation of interparticle interactions has high
data parallelism because the computation of particles is 
independent of each other. Therefore, 
Parallelism by SIMD\lparen Single Instruction/Multiple Data \rparen, 
one of Flynn's taxonomy \cite{flynn1972some} , is suitable.
SIMD means processing multiple data for a single instruction.
However, to perform SIMD, code must be written for the computer architecture.

The goal of this study is to allow users to run particle interaction 
calculations in parallel without having to be aware of parallelization.
We developed a Domain Specific Language\lparen DSL \rparen called Pyker.
DSL is a programming language for solving specific problems.
Pyker generates parallelized code with SIMD instructions for the 
calculation of interactions from the definition of variables and 
the description of formulas.
The evaluation method for Pyker is to compare the performance of 
the automatic SIMD  performed by the C compiler with that of the 
SIMD by Pyker. 
For this purpose, we measured the execution time of the code that
does not adapt the SIMD instructions generated by Pyker for each 
of the three interaction calculations.
The execution time of the code that does not adapt SIMD instructions
generated from Pyker and the code that does adapt SIMD instructions 
are measured and compared.

In this paper, section 2 explains how Pyker defines the interparticle 
interaction equation, section 3 describes the process of code generation 
by Pyker, and section 4 presents the results of the performance evaluation
experiments.

\section{Definition of the interparticle interaction in Pyker}

\subsection{interparticle interaction}
we explain the needed for information to the calculate interparticle 
interaction with reference to the actual code.
gravity.cpp is the C++ source code that performs the calculation 
in equation \eqref{eq:gravity}.
\begin{lstlisting}[frame=single, caption=skeleton code, label=fuga]
                  
  for (int i = 0; i < n; i++) {
    double ax = 0.0;
    double ay = 0.0;
    double az = 0.0;

    for (int j = 0; j < n; j++) {
        double dx = double(xj[j][0] - xi[i][0]);
        double dy = double(xj[j][1] - xi[i][1]);
        double dz = double(xj[j][2] - xi[i][2]);
        double r2 = dx * dx + dy * dy + dz * dz + eps2;
        double ri2 = 1.0f / sqrt(r2); 
        
        double mr = mj[j] * ri2 * ri2 * ri2;

        ax += double(mr * dx);
        ay += double(mr * dy);
        az += double(mr * dz);
    }

    acci[i][0] = ax;
    acci[i][1] = ay;
    acci[i][2] = az;
}
\end{lstlisting}

We will explain how this code corresponds to the expression 
\eqref{eq:gravity}.
acci,xi,mj,xj,eps2 correspond to
 $a_i$, $\vb{x}_i$ $m_j$,$\vb{x}_j$,$N$,$\epsilon$ respectively.
The $G$ is not in the code because it can be calculated after the 
calculation of the interparticle interactions.


 From this code, we can see that the variables to store the results, 
the variables for particle i and particle j respectively, and the 
variables for $N$ and $G$ can be calculated after the calculation of 
the particle-particle interaction. The other variables have different 
processing and data structures.


 Therefore, there are three categories of information in a variable.
\begin{itemize}
  \item Whether the variable is a particle i, a particle j, a
  variable that stores the result, or any other variable
  \item The type information of the variable.
  \item Whether the variable is a vector or not
\end{itemize}

 With the definition of this variable and a description of the
mathematical equation using the variable, a code to calculate the
interparticle interaction can be generated.
We explain the language specification in the next section.

\subsection{language specification}
There are two parts in Pyker. variable definition part and 
interaction description part.
First, we explain about the variable definition part.

\subsubsection{variable definition part}
Variable definitions are shown below in regular expressions.
% \begin{lstlisting}  
\["(EPI|EPJ|FORCE)?\:\text{ } (vec3<)?(F64)>?\:\text{ } \text{\textbackslash w+}"\]
% \end{lstlisting}
EPI and EPJ represent the variables for particles i and j, 
respectively, and FORCE indicates that they are variables that
 store the results.   Other variables are not written.


 Vector are denoted by vec3.If variable is a vector, the variable type
 is defined in '<>'.

Variable type is 'F64' for double-precision.In Pyker, Variable type is only 'F64'.

Finally, the name of the variable is written.


Next, the interaction description is explained.

In Pyker, you can use four arithmetic operations and sqrt(), power 
multiplication, vector inner product, assignment, and '+=' for formulas.
The operations that can be used to describe interactions are 
shown in the following figure.
\begin{lstlisting}[frame=single]
 +, -, /, *, **, sqrt(), =, +=
\end{lstlisting}
\begin{itemize}
  \item The $+, -, *,  /$ denote addition, subtraction, 
  multiplication, and division, respectively. 
  \item $**$ denotes a power
  \item sqrt() denotes a square root.
  \item When both terms of $*$ are vectors and the base of $**$ is 
  a vector and the exponent is 2, respectively, the calculation is
   determined to be an inner product.
  \item The $+=$ indicates that the result of the calculation is added to the FORCE variable. 
  \item $=$ is Assignment
\end{itemize}

In principle, if the elements are vectors, the operation is
performed on each element of the vector.


 The objects that can be used for the description are variables 
 that have been defined and temporary variables and floats defined 
 prior to the description.
 The following is an example of a Pyker description 
 of the calculation of the table \label{eq:gravity}
\begin{lstlisting}[frame=single, caption=gravity\_interparticle, label=fuga]
  EPI vec3<F64> ri
  EPJ vec3<F64> rj
  EPJ F64 mass
  EPJ F64 eps2
  FORCE vec3<F64> ai
  rij = ri - rj
  r2 = rij * rij + eps2
  r_inv = 1.0 / sqrt(r2)
  r2_inv = r_inv * r_inv
  mr_inv = mass * r_inv
  mr3_inv = r2_inv * mr_inv
  ai += mr3_inv * rij
\end{lstlisting}

次に、これらの記述からSIMD命令を行えるコードを生成する説明をする。

\section{Parser of Pyker}
Pykerでは、
このセクションでは、まずどのようにしてSIMDによる並列化を行うか説明し、その後Pykerの記述の読み込みからコード生成までの処理内容と流れを説明します。


\subsubsection{AVX2 for parallelization}

\subsubsection{Flow of Parse}


\section{Experiments}

\subsection{gravity interparticle}


\begin{lstlisting}[frame=single, caption=Nbody-kernel.pyker, label=Nbody-kernel.pyker]
  EPI vec3<F64> ri
  EPJ vec3<F64> rj
  EPJ F64 mass
  EPJ F64 eps2
  FORCE vec3<F64> ai
  rij = ri - rj
  r2 = rij * rij + eps2
  r_inv = 1.0 / sqrt(r2)
  r2_inv = r_inv * r_inv
  mr_inv = mass * r_inv
  mr3_inv = r2_inv * mr_inv
  ai = mr3_inv * rij
  \end{lstlisting}

\begin{lstlisting}[frame=single, caption=Nbody-kernel.pikg, label=Nbody-kernel.pikg]
  EPI F64vec ri:r
  EPJ F64vec rj:r
  EPJ F64 mj:m
  EPJ F64 eps2:eps
  FORCE F64vec ai:acc
  rij = ri - rj
  r2 = rij * rij + eps2
  r_inv  = rsqrt(r2)
  r2_inv = r_inv * r_inv
  mr_inv  = mj * r_inv
  mr3_inv = r2_inv * mr_inv
  ai += mr3_inv * rij
  
\end{lstlisting}




non-simd

g++ -O3 

\begin{tabular}{|l|r|r|} \hline
  N & Pyker & PIKG \\ \hline
  25000 & 6.725156 & 4.444766 \\
  10000 & 0.738918sec & 0.517324sec \\
 \\ \hline
\end{tabular}


\begin{lstlisting}[frame=single, caption=Nbody-kernel.pikg, label=Nbody-kernel.pikg]
  g++ -O3 -I ~/school/PIKG/PIKG/inc -mavx2 -mfma gravity_interparticle.cpp
  
  \end{lstlisting}



  \begin{tabular}{|l|r|r|} \hline
    N & Pyker(sec) & PIKG(sec) \\ \hline
    50000 & 5.119071 & 3.333270\\
    25000 & 1.218129 & 1.148511 \\
    10000 & 0.143777 & 0.101594 \\
    1000 &  0.003521 & 0.002168 \\ \hline
  \end{tabular}
  
% \begin{tabular}{lrr}
%   N & pyker & PIKG \\
%   10000 & 0.143777sec & 0.101594sec \\
%   x & y & z 
%  \end{tabular}

\subsection{LennardJones}

\begin{lstlisting}[frame=single, caption=LennardJones-kernel.pyker, label=LennardJones-kernel.pyker]
EPI F64 rix
EPI F64 riy
EPI F64 riz
EPJ F64 rjx
EPJ F64 rjy
EPJ F64 rjz
EPJ F64 eps

FORCE F64 fx
FORCE F64 fy
FORCE F64 fz
FORCE F64 p
dx = rix - rjx
dy = riy - rjy
dz = riz - rjz
r2 = dx * dx + dy * dy + dz * dz + eps
r2i = 1.0 / r2
r6i = r2i * r2i * r2i
f = (48.0* r6i - 24.0) * r6i * r2i
fx = f * dx
fy = f * dy
fz = f * dz
p = 4.0 * (r6i) * (r6i - 1.0)
\end{lstlisting}
\begin{lstlisting}[frame=single, caption=LennardJones-kernel.pyker, label=LennardJones-kernel.pyker]
  EPI F64 rix:rx
  EPI F64 riy:ry
  EPI F64 riz:rz
  
  EPJ F64 rjx:rx
  EPJ F64 rjy:ry
  EPJ F64 rjz:rz
  EPJ F64 eps2:eps
  
  FORCE F64 fx:fx
  FORCE F64 fy:fy
  FORCE F64 fz:fz
  FORCE F64 p:p
  
  dx  = rix - rjx
  dy = riy - rjy
  dz  = riz - rjz
  r2  = dx * dx + dy * dy + dz * dz + eps2
  r2i = 1.0 / r2
  r6i = r2i * r2i * r2i
  f = (48.0 * r6i - 24.0) * r6i * r2i
  fx += f * dx
  fy += f * dy
  fz += f * dz
  p += 4.0 * r6i*(r6i - 1.0)

\end{lstlisting}


non-simd
\begin{tabular}{|l|r|r|} \hline
  N & Pyker & PIKG \\ \hline
  50000 & 40.736862 & 11.656278 \\
  25000 & 10.662050 & 3.521253 \\
  10000 & 0.985475 & 0.442775 \\
 \\ \hline
\end{tabular}


simd
\begin{tabular}{|l|r|r|} \hline
  N & Pyker & PIKG \\ \hline
  50000 & 3.702871  & 2.838773\\
  25000 & 0.838122 & 0.9904373 \\
  10000 & 0.134388 & 0.215270 \\

 \\ \hline
\end{tabular}



\section{Conclusion}
\section{Acknowledgement}


\begin{thebibliography}{99}
\end{thebibliography}
\bibliography{biblist}


\end{document}